#pragma once
#include "orland_vect.h"
#include <vector>

namespace orland {
	class Object {
	public:
		Object() = default;
		
		// Поворачивает все векторы на заданный угол в градусах
		void RotateAll(double angle);

		// Смещает все векторы на заданное расстояние
		void MoveAll(const Vector2D& move);
	private:
		std::vector<Vector2D> desk_;
	};
}//namespace orland

/*
Рассчитывая нормаль и сравнивая с вектором взгляда можно определять видимость
и освещенность объекта для смотрящего. Если нормаль перпендикулярна к вектору взгляда 
наблюдателя, то он не видит образованную фигуру.

У октаэдра берем одну грань и три вектора, образующие треугольник этой грани.
Располагаем v1 v2 и v3 так, чтобы (v2 - v1) x (v3-v1) сотрел наружу

Выбираем направление в трехмерном пространстве, с которого будем смотреть на объект - определяем два вектора,
которые задают направление вверх и вправо с нашей точки обзора

берем функцию component, которая считает скалярное прозведение 3D вектора и вектора заданного 
направления и делит значение на длину вектора 
направления - т.е дает длину тени 3d вектора на плоскости заданного направления

И чтобы получить проекцию трехмерного треугольника на плосокть, нужно все его вершины прогнать через эту функцию

Выбираем точку света
Ищем угол между перпендикуляром к грани и направлением источника света - чем меньше угол, тем ярче освещение

Считаем нормаль к грани.
Считаем скалярное произведение нормали и вектора, направленного на источник
света - проверяем сонаправленность.Если векторы сонапправлены, и брать их единичными длинами, то скалярное произведение даст значение от 0 до 1.
Чем больше скалярное произведение (ближе к 1), тем ярче освещение


*/
